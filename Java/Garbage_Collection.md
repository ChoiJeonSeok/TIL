# Java 가비지 컬렉션(GC)

## **Java 가비지 컬렉션의 개요**
- Java 가비지 컬렉션은 Java Virtual Machine(JVM) 내에서 사용되지 않는 객체들을 자동으로 식별하고, 그 메모리를 해제하는 과정이다. 
- 이 프로세스는 자동으로 수행되어 개발자가 메모리 관리에 대해 걱정할 필요가 적어지고, 메모리 누수와 같은 문제를 방지하는 데 도움이 된다.

### **JVM 메모리 구조**
- **힙 메모리**: 객체가 저장되는 주요 영역. 힙은 크게 세 부분으로 나뉜다:
  - **Young Generation**: 새로 생성된 객체들이 배치되는 곳이다. 여기서 객체들은 비교적 짧은 생명주기를 가진다.
  - **Old Generation**: Young Generation에서 오래 살아남은 객체들이 이동하는 곳이다. 여기서 객체들은 더 긴 생명주기를 가진다.
  - **Permanent Generation(Metaspace)**: 클래스와 메서드에 대한 메타데이터가 저장되는 곳이다. Java 8 이후, 이 영역은 Metaspace로 대체되었다고 한다.
- **비힙 메모리**: 이 영역은 JVM에 의해 사용되는 메모리로, 클래스 메타데이터, 컴파일된 코드, JIT 컴파일러에 의한 최적화 정보 등을 저장한다.

### **가비지 컬렉션 작동 원리**
- **Minor GC**: Young Generation에서 발생한다. 새로 생성된 대부분의 객체들은 여기서 소멸된다.
- **Major GC (Full GC)**: Old Generation에서 발생한다. 이 과정은 더 시간이 많이 걸리고, 리소스를 더 많이 사용한다.
- **Full GC**: 전체 힙과 Permanent Generation 또는 Metaspace를 대상으로 한다. 가장 오래 걸리고 가장 많은 리소스를 사용하는 GC 과정이다.

### **가비지 컬렉션 알고리즘**
- **Serial GC**: 단일 스레드 환경에서 사용된다. 간단하지만, 작업 중에는 다른 스레드가 중단된다.
- **Parallel GC**: 다중 스레드 환경에서 사용된다. 더 빠른 처리가 가능하지만, 더 많은 CPU 리소스를 필요로 한다.
- **CMS (Concurrent Mark Sweep) GC**: Old Generation에서 동시성을 가지고 작동하여, 애플리케이션의 중단 시간을 줄인다.
- **G1 Garbage Collector**: 힙을 여러 영역으로 나누고, 가장 많이 채워진 영역부터 수집한다. 더 큰 힙과 멀티프로세서 환경에 적합하다.

### **'Stop-the-World' 이벤트**
- GC가 실행되는 동안, JVM은 애플리케이션의 모든 스레드를 일시적으로 중단한다. 
- 이는 GC가 메모리를 안전하게 정리할 수 있도록 보장하지만, 이로 인해 애플리케이션의 성능이 일시적으로 저하될 수 있다.

### **가비지 컬렉션 튜닝**
- 적절한 GC 전략을 선택하고 JVM 옵션을 조정함으로써 GC의 성능을 최적화할 수 있다. 
- 이는 애플리케이션의 요구사항과 하드웨어 자원에 따라 달라질 수 있다.

### **장단점**
- **장점**: 자동 메모리 관리, 메모리 누수 방지
- **단점**: GC 작업 중 성능 저하 가능성

### **결론**
Java 가비지 컬렉션은 효율적인 메모리 관리를 위해 필수적이지만, JVM의 구조와 가비지 컬렉터의 선택 및 튜닝, 그리고 객체의 생명주기를 관리하는 데 있어서 충분한 이해와 적절한 사용이 요구된다.

## 가비지 컬렉션의 세부 작동 단계

1. **Marking (표시) 단계**:
   - 모든 변수를 스캔하면서 각 변수가 참조하고 있는 객체를 마킹합니다.
   - 루트 객체(스택, 전역 변수, 레지스터 등에서 직접 참조되는 객체)부터 시작하여 참조되는 모든 객체를 추적합니다.
   - 가비지로 판단되는 객체를 표시합니다.

2. **Sweeping (해제) 단계**:
   - 마크되지 않은 객체들을 힙 메모리에서 제거합니다.
   - 이로 인해 해당 영역은 재사용될 수 있게 됩니다.

3. **Compaction (선택적)**:
   - 가비지 컬렉션 후 메모리에 흩어져 있는 미사용 영역을 정리합니다.
   - 연속된 사용 가능한 메모리 공간을 만들어줍니다.