# 윈도우 함수(Window Function)란?

- 윈도우 함수는 SQL에서 데이터를 처리하고 분석하는 강력한 기능이다. 기존의 집계 함수와 달리 각 행에 대해 계산되며, 데이터를 그룹화하거나 정렬하여 윈도우(범위)를 정의하여 작동한다. 이를 통해 윈도우 함수는 데이터의 세분화된 처리와 분석을 가능하게 한다.

## 윈도우 함수의 개념

- 윈도우 함수는 데이터 집합 내에서 작동하는 특별한 함수로, 각 행에 대해 계산을 수행한다. 이때, 윈도우 함수가 작동할 데이터 집합은 OVER 절을 통해 정의된다. OVER 절은 윈도우 함수의 핵심 구성 요소로, PARTITION BY, ORDER BY 등의 구문을 포함할 수 있다. PARTITION BY 구문은 데이터를 그룹화할 기준을 제공하고, ORDER BY 구문은 데이터의 정렬 순서를 지정한다.

- 윈도우 함수는 데이터 집합 내에서 윈도우 프레임(Frame)을 사용하여 작동한다. 윈도우 프레임은 윈도우 함수가 적용될 데이터의 범위를 정의하며, ROWS와 RANGE 두 가지 종류의 프레임이 있다. ROWS 프레임은 행의 개수를 기준으로 범위를 지정하고, RANGE 프레임은 값의 논리적인 범위를 기준으로 범위를 지정한다.

## 윈도우 함수의 사용 이유

- 윈도우 함수는 데이터 분석과 처리에 있어 다양한 이유로 사용된다.

1. 유연한 계산: 윈도우 함수는 각 행에 대해 계산을 수행하므로, 세부적이고 유연한 계산이 가능하다. 예를 들어, 각 집단 내에서의 순위, 이동 평균, 누적 합 등을 계산할 수 있다.

2. 복잡한 쿼리 단순화: 기존에는 복잡한 쿼리를 작성하거나 서브쿼리를 사용하여 처리해야 했던 작업들을 윈도우 함수를 사용하여 간결하게 표현할 수 있다. 이는 코드의 가독성을 높이고 유지보수를 용이하게 한다.

3. 성능 향상: 윈도우 함수는 SQL 엔진에 내장되어 있으며, 최적화된 실행 계획을 생성하여 빠른 처리 속도를 제공한다. 따라서 대용량 데이터 처리에도 효율적으로 사용할 수 있다.

## 윈도우 함수의 장단점

- 윈도우 함수의 사용은 다음과 같은 장점과 단점을 가지고 있다.

### 장점:
- 세분화된 데이터 처리: 각 행에 대한 계산으로 세부적인 데이터 처리가 가능하다.
- 복잡한 쿼리 간결화: 복잡한 쿼리를 단순하고 가독성 좋게 작성할 수 있다.
- 성능 최적화: SQL 엔진에 내장되어 최적화된 실행 계획으로 빠른 처리 속도를 제공한다.

### 단점:
- 사용의 난이도: 윈도우 함수의 개념과 구문을 이해하고 사용하는 데에는 학습이 필요하다.
- 일부 데이터베이스 시스템의 제한: 일부 데이터베이스 시스템은 윈도우 함수를 지원하지 않거나, 일부 기능이 제한될 수 있다.


## 윈도우 함수의 기본 구문
- OVER 절의 역할과 구성 요소: OVER 절은 윈도우 함수의 핵심 구성 요소로, 윈도우 함수가 적용될 데이터 집합을 정의합니다. OVER 절에는 PARTITION BY, ORDER BY, ROWS/RANGE 등의 구문이 포함될 수 있다.
- PARTITION BY 구문: PARTITION BY 구문은 데이터를 특정 기준에 따라 분할하여, 각 파티션 내에서 윈도우 함수가 적용된다. 예를 들어, PARTITION BY 구문을 사용하여 지역별로 데이터를 분할한 후, 각 지역별로 윈도우 함수를 적용할 수 있다.
- ORDER BY 구문: ORDER BY 구문은 데이터를 특정 기준에 따라 정렬한다. 윈도우 함수의 결과는 ORDER BY 구문에 따라 달라질 수 있다.
- 윈도우 프레임(Frame)의 종류: 윈도우 프레임은 윈도우 함수가 적용될 데이터 범위를 정의한다. ROWS와 RANGE 두 가지 종류의 프레임이 있으며, 각각 다른 방식으로 데이터 범위를 지정한다.

## 윈도우 함수 종류
### ROW_NUMBER 함수
- ROW_NUMBER 함수의 동작과 사용법: ROW_NUMBER 함수는 각 행에 대해 고유한 번호를 부여한다. 이 번호는 OVER 절에서 지정한 PARTITION BY와 ORDER BY 구문에 따라 결정된다.
- 예시: ROW_NUMBER 함수를 사용한 고유 번호 부여: 
```sql
ROW_NUMBER 함수를 사용하여 지역별로 고유 번호를 부여하는 예제 :
SELECT 지역, 이름, ROW_NUMBER() OVER (PARTITION BY 지역 ORDER BY 이름) AS 번호
FROM 직원; 
```

### RANK, DENSE_RANK 함수
- RANK 함수와 DENSE_RANK 함수의 차이점: RANK 함수와 DENSE_RANK 함수는 모두 순위를 부여하는 함수이다. 차이점은 동일한 값을 가진 행들의 순위 처리 방식이다. RANK 함수는 동일한 값을 가진 행들에게 동일한 순위를 부여하고, 다음 순위는 건너뛴다. 반면 DENSE_RANK 함수는 동일한 값을 가진 행들에게 동일한 순위를 부여하고, 다음 순위는 건너뛰지 않는다.
- 예시: RANK 함수와 DENSE_RANK 함수의 활용: 
```sql
ANK와 DENSE_RANK 함수를 사용하여 지역별로 매출액 순위를 부여하는 예제 :
SELECT 지역, 매출액, RANK() OVER (PARTITION BY 지역 ORDER BY 매출액 DESC) AS 순위,
DENSE_RANK() OVER (PARTITION BY 지역 ORDER BY 매출액 DESC) AS 밀집순위
FROM 매장;
```

### LAG, LEAD 함수
- LAG 함수와 LEAD 함수의 개념과 활용: LAG와 LEAD 함수는 현재 행과 이전/다음 행 간의 값을 비교하거나 계산하는 데 사용된다. LAG 함수는 현재 행보다 이전 행의 값을 반환하고, LEAD 함수는 현재 행보다 다음 행의 값을 반환한다.
- 예시: LAG 함수와 LEAD 함수를 활용한 시계열 데이터 처리: 
```sql
LAG함수를 사용하여 전월 대비 매출 증감률을 계산하는 예제 :
SELECT 날짜, 매출액,
(매출액 - LAG(매출액) OVER (ORDER BY 날짜)) / LAG(매출액) OVER (ORDER BY 날짜) * 100 AS 증감률
FROM 매출;
```

### SUM, AVG 함수
- SUM 함수와 AVG 함수의 사용법과 응용: SUM과 AVG 함수는 각각 합계와 평균을 계산하는 함수이다. 윈도우 함수로 사용될 경우, OVER 절에서 지정한 범위 내에서 합계나 평균을 계산한다.
- 예시: SUM 함수와 AVG 함수를 활용한 데이터 집계:
```sql
SUM함수를 사용하여 지역별 누적 매출액을 계산하는 예제 :
SELECT 지역, 날짜, 매출액,
SUM(매출액) OVER (PARTITION BY 지역 ORDER BY 날짜 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS 누적매출
FROM 매출;
```

## 심화 주제
- 윈도우 함수와 조인 연산의 결합: 윈도우 함수는 조인 연산과 함께 사용될 수 있다. 예를 들어, 윈도우 함수를 사용하여 각 직원의 급여 순위를 계산한 후, 조인 연산을 사용하여 각 직원의 부서 정보를 추가할 수 있다.
- 윈도우 함수의 성능과 최적화: 윈도우 함수는 대용량 데이터에서도 빠른 성능을 보인다. 하지만, 데이터가 매우 클 경우 성능이 저하될 수 있다. 이때는 인덱스 생성, 파티션 분할 등의 방법으로 성능을 최적화할 수 있다.

## 그 외 함수들
### FIRST_VALUE 함수
- 특정 윈도우의 첫 번째 값을 반환한다. 각 그룹의 시작 값을 찾을 때 사용하면 좋다.
- `판매기록` 테이블에서 각 지역별로 가장 높은 판매액을 가진 첫 번째 값을 `지역별최고판매액`으로 선택한다. `PARTITION BY 지역`은 지역별로 데이터를 그룹화하고, `ORDER BY 판매액 DESC`로 판매액이 높은 순(내림차순)으로 정렬하여 각 지역에서 가장 높은 판매액을 가진 첫 번째 행을 반환한다.
```sql
SELECT 
  이름,
  판매액,
  FIRST_VALUE(판매액) OVER (PARTITION BY 지역 ORDER BY 판매액 DESC) AS 지역별최고판매액
FROM 판매기록;
```

### LAST_VALUE 함수
- 특정 윈도우의 마지막 값을 반환한다. 각 그룹의 마지막 값을 찾을 때 사용할 수 있다. `ROWS BETWEEN`와 같은 윈도우 범위를 조정해야 마지막 값이 제대로 반영된다.
- 각 지역별로 가장 낮은 판매액을 가진 마지막 값을 `지역별최저판매액`으로 선택한다. `ROWS ...`행은 현재 행부터 파티션의 마지막 행까지를 윈도우 범위로 설정하여 `ORDER BY`로 인해 마지막 행이 실제로는 최소 판매액이 되도록 한다.
```sql
SELECT 
  이름,
  판매액,
  LAST_VALUE(판매액) OVER (
    PARTITION BY 지역 
    ORDER BY 판매액 DESC 
    ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) AS 지역별최저판매액
FROM 판매기록;
```

### NTILE 함수
- 주어진 수의 동등한 분할로 데이터 집합을 나누고, 각 행가 속한 분할 번호를 반환한다. 예를 들어, NTILE(4)는 전체 데이터를 4개의 분위로 나누고, 각 행에 1부터 4까지의 분위 번호를 할당한다.
- `판매기록` 테이블의 전체 데이터를 판매액에 따라 내림차순으로 정렬하고, 이를 4개의 동일한 크기로 나눈 뒤, 각 행이 속하는 분위 번호를 `판매액분위`로 표시한다. 예를 들어 전체 데이터의 행이 100개가 있다면, 상위 25개의 행은 판매액분위 1에, 다음 25개의 행은 판매액분위 2에 할당된다.
```sql
SELECT 
  이름,
  판매액,
  NTILE(4) OVER (ORDER BY 판매액 DESC) AS 판매액분위
FROM 판매기록;
```

### CUME_DIST 함수
- 현재 행이 위치한 상대적 순위를 전체 행 개수에 대한 누적 분포로 반환한다. 퍼센타일 또는 순위를 구할 때 유용하다.
- 각 행의 `판매액`을 기준으로 내림차순 정렬하여, 그 행 이하의 누적 분포를 `누적분포도`로 계산한다. 누적 분포는 현재 행을 포함하여 그보다 높거나 같은 판매액을 가진 행의 비율을 나타낸다.
```sql
SELECT 
  이름,
  판매액,
  CUME_DIST() OVER (ORDER BY 판매액 DESC) AS 누적분포도
FROM 판매기록;
```

### PERCENT_RANK 함수
- 각 행의 백분위 순위를 반환한다. `RANK`와 유사하지만 백분위를 기준으로 계산한다.
- 각 행의 `판매액`을 기준으로 내림차순 정렬하여, 각 행의 백분위 순위를 `백분위순위`로 계산한다. 백분위 순위는 최소 판매액을 0, 최대 판매액을 1로 두고 각 행의 상대적 위치를 백분위 값으로 나타낸다.
```sql
SELECT 
  이름,
  판매액,
  PERCENT_RANK() OVER (ORDER BY 판매액 DESC) AS 백분위순위
FROM 판매기록;
```


### OVER 절
- 윈도우 함수를 사용할 때, `OVER` 절을 통해 윈도우를 정의한다. 이 절에서는 `PARTITION BY`로 데이터를 분할하고, `ORDER BY`로 순서를 정렬하며, `ROWS`나 `RANGE`로 윈도우의 범위를 지정할 수 있다.
- 각 지역별로 이전 판매액과 현재 행의 판매액을 합하여 `이동평균판매액`을 계산한다. `OVER` 절 내에서 `PARTITION BY 지역`은 지역별로 데이터를 분할하여 각 지역 내에서 연산을 수행하도록 한다.
- `ORDER BY 날짜`는 각 지역 내의 데이터를 날짜에 따라 순서대로 정렬한다.
- `ROWS BETWEEN 1 PRECEDING AND CURRENT ROW`는 현재 행과 바로 이전 행을 윈도우의 범위로 지정하여, 해당 범위 내의 판매액을 합산한다. 즉, 이는 이동평균을 구한 것이다.
```sql
SELECT 
  이름,
  판매액,
  SUM(판매액) OVER (
    PARTITION BY 지역 
    ORDER BY 날짜 
    ROWS BETWEEN 1 PRECEDING AND CURRENT ROW
  ) AS 이동평균판매액
FROM 판매기록;
```