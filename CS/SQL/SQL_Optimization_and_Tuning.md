# 쿼리 최적화 기초

## 실행 계획 분석
- **정의**: 실행 계획은 데이터베이스가 쿼리를 어떻게 수행할지에 대한 로드맵이다. 이를 분석함으로써 쿼리의 성능을 이해하고 개선할 수 있다.
  
- **사용법**: 대부분의 데이터베이스 관리 시스템(DBMS)에서는 `EXPLAIN`이나 `EXPLAIN PLAN`과 같은 명령어를 사용하여 실행 계획을 확인할 수 있다.
    ```sql
    EXPLAIN SELECT * FROM tableA WHERE column1 = 'value';
    ```
  
- **분석 방법**: 실행 계획을 통해 테이블 스캔의 유무, 사용된 인덱스, 조인 방법 등을 확인할 수 있다.

## 쿼리 최적화 팁
- **WHERE 절 최적화**: 불필요한 조건은 제거하고, 인덱스를 활용할 수 있는 조건을 사용하자.
- **JOIN 최적화**: 가능하면 INNER JOIN을 사용하고, 필요한 컬럼만 SELECT 하자.
- **결과 집합 최적화**: `LIMIT`과 `OFFSET`을 적절히 사용하여 필요한 만큼의 데이터만 가져오자.

# 인덱스 튜닝

## 인덱스 선택 기준
- **정의**: 모든 컬럼에 인덱스를 생성하는 것은 비효율적이다. 따라서 어떤 컬럼에 인덱스를 생성할지를 결정하는 기준이 필요하다.
- **선택 기준**: 
    1. WHERE, JOIN, ORDER BY 절에서 자주 사용되는 컬럼
    2. 데이터의 카디널리티가 높은 컬럼
    3. 읽기 작업이 많고, 쓰기 작업이 적은 컬럼

## 클러스터링, 논클러스터링 인덱스
- **클러스터링 인덱스**: 데이터의 물리적인 저장 순서를 변경하여 데이터를 빠르게 읽을 수 있게 하는 인덱스.
    - **예시**: 
    ```sql
    CREATE CLUSTERED INDEX index_name ON table_name(column_name);
    ```
  
- **논클러스터링 인덱스**: 데이터의 물리적인 저장 순서를 변경하지 않고, 별도의 공간에 인덱스를 저장하는 방법.
    - **예시**: 
    ```sql
    CREATE NONCLUSTERED INDEX index_name ON table_name(column_name);
    ```

- **어떤 것을 사용할까**: 클러스터링 인덱스는 읽기 작업이 빠르지만 쓰기 작업에는 비효율적이다. 논클러스터링 인덱스는 읽기 작업이 느릴 수 있지만, 쓰기 작업에는 덜 민감하다. 따라서 사용 사례에 따라 적절한 인덱스를 선택해야 한다.