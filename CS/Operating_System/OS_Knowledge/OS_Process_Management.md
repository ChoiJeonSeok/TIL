# 2. 프로세스 관리

## 프로세스의 정의 및 특성

### **정의**
- 프로세스는 실행 중인 프로그램이다. 이는 코드, 데이터, 힙, 스택 등으로 구성되며, 운영체제가 관리하는 자원과 상태 정보를 포함한다.
### **프로세스 구성요소**
  - **코드**: 프로그램의 실행 가능한 명령어들이 저장되는 영역
  - **데이터**: 프로그램 실행 중에사용되는 변수, 배열 등의 데이터가 저장되는 영역
  - **힙(Heap)**: 프로그램 실행 중 동적으로 할당되는 메모리가 위치하는 영역. Java에서 `new` 연산자를 통해 할당되는 메모리가 이곳에 위치한다.
  - **스택(Stack)**: 함수의 호출과 관련된 지역 변수, 매개변수, 반환 주소(Return) 등이 저장되는 영역. 함수 호출 시 생성되고, 반환 시 제거된다.
### **운영체제가 관리하는 자원과 상태 정보**
  - **자원**: CPU, 메모리 공간, 파일 저장소, I/O 장치 등
  - **상태 정보**: 프로세스 ID, 프로세스 상태, 프로그램 카운터, 우선순위 CPU 레지스터, 메모리 관리 정보 등
### **특성**
  - **동적 속성**: 프로세스는 실행 중에 생성되고, 상태가 변하며, 소멸한다.
  - **병렬성**: 다수의 프로세스가 동시에 실행될 수 있다.
  - **독립성 및 상호작용**: 프로세스는 독립적으로 실행되거나 다른 프로세스와 상호작용할 수 있다.

## 프로세스의 상태 및 상태 전이

### **상태**
  - **새로 생성(New)**: 프로세스 생성 중.
  - **실행 가능(Runnable)**: CPU에서 실행될 준비가 됨.
  - **실행 중(Running)**: CPU에서 명령어를 실행 중.
  - **대기 중(Waiting)**: 특정 이벤트(예: I/O 완료)를 기다림.
  - **종료(Terminated)**: 실행 완료 후 소멸.
### **상태 전이**
  - **디스패치(Dispatch)**: 스케줄러가 프로세스를 선택하여 CPU에 할당하는 과정. 
    - 실행 가능 상태에서 실행 중으로 전환.
  - **블로킹(Block)**: 프로세스가 I/O 작업과 같은 특정 작업을 수행하면서 대기 상태로 전환. 
    - 실행 중에서 대기 중으로 전환.
  - **깨어남(Wakeup)**: 대기 상태의 프로세스가 대기 중인 이벤트(예: I/O 작업 완료)가 발생하여 다시 실행 가능 상태로 전환. 
    - 대기 중에서 실행 가능으로 전환.

## 스케줄링

### **목적**
- CPU 사용을 최적화하고, 시스템 성능을 향상시키기 위해 프로세스에 CPU를 할당하는 방법을 결정한다.

### **알고리즘 예시**
  - **FCFS(First Come First Served)** or FIFO(First-in, First-out)
    - 가장 먼저 도착한 프로세스를 먼저 서비스하는 방식. 단순하지만, 짧은 작업이 긴 작업 뒤에 도착하면 오래 기다려야 하는 문제가 있다.
  - **RR(Round Robin)**
    - 프로세스에게 동일한 크기의 시간 할당량(타임 퀀텀)을 부여하고, 이 시간이 끝나면 다음 프로세스에게 CPU를 할당하는 방식. 다양한 유형의 작업이 혼합된 환경에서 잘 작동한다.
    - 프로세스가 타임 퀀텀 내에 작업을 완료하지 못하면, 실행 중이던 프로세스는 대기 큐의 끝으로 이동한다. 
    - 공평한 시간 분배를 가능하게 하지만 모든 또는 대부분의 프로세스가 타임 퀀텀보다 긴 작업을 수행해야 하는 최악의 시나리오에서는 효율적이지 않다. 시스템의 전체적인 응답 시간이 늦어질 수 있어 `컨베이어 벨트` 효과가 발생할 수 있다.

    <details>
    <summary>타임 퀀텀(Time Quantum)</summary>

    - 각 프로세스가 CPU를 사용할 수 있는 최대 시간을 의미한다. 
    - 몇 밀리초(ms)에서 수십 밀리초 사이로 설정된다.
    - RR 스케줄링의 성능에 중요한 영향을 미친다. 너무 짧으면 Context Switching Overhead가 커지고, 너무 길면 FCFS 스케줄링과 유사해진다.

    <details>
    <summary>Context Switching</summary>

        - 운영체제가 현재 실행 중인 프로세스(or thread)를 중지하고 다른 프로세스를 실행하는 과정을 의미한다.
        - 이 과정에서 현재 프로세스의 상태(Context)를 저장하고, 새로 실행될 프로세스의 상태를 불러오는 작업이 포함된다.
        - Context에는 프로세스의 프로그램 카운터, 레지스터 값, 메모리 관리 정보, 스택의 상태 등이 포함된다.
        - Context Switching 비용은 이러한 전환 과정에서 발생하는 Overhead(추가적인 자원 소모)를 의미한다. CPU가 전환 작업에 시간을 소비하기 때문에, 시스템의 전체적인 성능에 영향을 미칠 수 있다.
        - 타임 퀀텀이 짧은 RR 스케줄링에서는 빈번한 Context Switching이 발생할 수 있어, 이러한 비용이 중요한 고려 요소가 된다.
    </details>
    </details> 

    <details>
    <summary>컨베이어 벨트 효과</summary>

    - Round Robin 스케줄링에서 모든 프로세스의 작업 시간이 타임 퀀텀보다 길 경우 발생하는 현상을 비유적으로 설명한 용어. 프로세스들이 컨베이어 벨트 위에 올라가 있는 물건처럼 순환하게 된다.
    - 모든 프로세스가 타임 퀀텀보다 긴 작업을 수행하기 때문에, 어떤 프로세스도 완전히 끝나지 않고 계속 순환하게 된다.
    - 시스템의 전체적인 응답 시간이 늘고, 효율성이 감소한다.
    </details>
  

  - **우선순위 스케줄링**
    - 각 프로세스에 우선순위를 부여하고, 높은 우선순위를 가진 프로세스부터 CPU를 할당한다. 우선순위가 낮은 프로세스는 긴 대기 시간을 가질 수 있다.
  - **다단계 큐 스케줄링**
    - 프로세스를 여러 큐에 나누고, 각 큐에 다른 스케줄링 알고리즘을 적용한다.
  - **최단 작업 먼저(SJF, Shortest Job First)**
    - 예상 실행 시간이 가장 짧은 프로세스를 먼저 선택한다. 평균 대기 시간을 줄일 수 있지만, 실행 시간 예측이 어렵다는 단점이 있다.

## 동기화 문제 및 해결방법

- **문제**: 병렬로 실행되는 프로세스들이 공유 자원에 접근할 때 발생한다.
- **해결방법**:
  - **뮤텍스(Mutex)**: 공유 자원에 한 번에 하나의 프로세스만 접근할 수 있도록 제한.
  - **세마포어(Semaphore)**: 뮤텍스를 일반화한 방법으로, 한정된 수의 프로세스가 공유 자원에 접근할 수 있다.
  - **모니터**: 프로세스 간의 동기화를 위해 사용되는 추상 데이터 타입.

## 교착상태와 그 해결 전략

- **교착상태**: 두 개 이상의 프로세스가 서로의 작업 완료를 무한정 기다리는 상태.
- **해결 전략**:
  - **예방**: 시스템이 교착상태가 되지 않도록 조치를 취함.
  - **회피**: 알고리즘을 사용하여 교착상태의 가능성을 줄임 (예: 은행원 알고리즘).
  - **검출 및 회복**: 교착상태를 검출하고 회복하는 방법을 사용.
  - **무시**: 교착상태가 매우 드물게 발생하거나 회복 비용이 매우 높을 때 선택할 수 있다.


분산 컴퓨팅 시스템 등에서 매우 중요하다. 리소스 관리, 작업 스케줄링, 동기화 문제 해결은 데이터 처리의 효율성과 신뢰성을 결정하는 핵심 요소이다.

